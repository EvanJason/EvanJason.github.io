---
title: 面试经历总结
categories:
  - 面试
tags:
  - 面试
date: "2022-10-02"
authors: lin
excerpt: 面试经历总结

---

# 面试经历总结

去面试的时候，和hr说工资的时候，就要说明好，不能只看我简历上的框架年限，
一开始喊高点！！！，10.5k
我进入目前就职的公司时，因为起步工资低，造成我的工资只有8000，加上去年年终，我们部门加薪名额有限，没能涨工资。现在满一年多了，我们公司11月份会涨薪一次，再加上年终，所以我是想要多点的，毕竟我如果进入贵公司，一年内，应该是没有机会涨工资。



## 问题

### 请介绍一下你这个项目的业务流程？包含的主要模块以及自己负责的工作



### 你在做这个项目中，遇到的最大的难点、或者解决过的最复杂的 Bug 是什么？



### 你的项目有实际上线么？使用哪种方式进行部署？





## 问面试官

1. 我这场面试表现怎么样？
1. 考勤，请假，加班，公积金按多少算，调薪



## 职业规划

 我想成为这个领域的专业化人士，但我明白这是一个长期努力的过程，现在我的初步打算是：

第一阶段，我希望从现在开始，1－2年之内能够在我目前申请的这个职位上沉淀下来，积累最起码的工作经验，把基础打牢。

第二阶段，我希望利用3－5年的时间，成为一个在自己的专业方面能够独当一面的人，能够独自承担责任，发现问题，解决问题，不让上司操心。

第三阶段，成为该领域的一名专业化人士，在工作中能有创新与发展，能为公司带来更大的价值。

后续当成为专业化人士，积累了一定的经验后，我会考虑是否坚持做一名技术专家还是成为一名产品经理或项目经理。

  

## 自我介绍

重点！！！



**一个万能公式：1+3+1法则**

在做自我介绍整体设计时，可以按照这样的框架，会让你的自我介绍至少60分~

> 第一，你是谁 ，用1句话做简单的背景介绍。
> 第二，你的3个亮点，或者说公司应该选择你的3个理由。可以是相关的经历、有事实支撑的技能、与岗位的匹配、你的优势等，梳理出独一无二的三条。
> 第三，你为什么想要这份工作？用1句话最后表达意愿你认为这个工作适合你，或者你为什么胜任这个工作！

比如：

> 面试官好，我叫李磊，来自XX大学XX专业，
> 今天来应聘新媒体运营这个岗位，我有3个优势，第一，专业能力，四年的学习给了我扎实的功底，XXXXX；第二，相关经验丰富，我曾经帮实习单位运营公众号，半年时间，粉丝量增长5倍+，XXXXXX；第三，性格特质匹配。 我自己数据分析能力比较强，有好奇心、创意能力强，比如曾经参加全国XXXXX大赛，XXXX。我了解到贵公司新媒体运营岗位主要定位人群是XXX，之前我也有过类似经验。 
> 因此，我认为自己非常适合这个岗位，也相信自己可以胜任，希望能获得这次机会。

再来一个：

> 面试官好，我是来自XXX的XXX，关于我有三个标签，
> 第一，有韧劲儿不任性的女汉子；XXXXX举例。
> 第二，即讲原则又懂灵活的萌妹子；XXXXX举例。
> 第三，靠谱届中的扛把子。XXXXX举例
> 综上，今天来应聘XXX岗位，我非常期待加入贵公司成为其中一员。

**其次，3P原则**：

设计完自我介绍后，可以按照3P法则来检查自己的自我介绍是否优秀，让你的自我介绍达到80分以上~

> **第一，自信（positive），**是否突出优势亮点，展现出足够的自信心和价值。是否
> **第二，个性（personal），**是否千篇一律还是有自己的个人特点，是否跳出大众化模式，把自己一个独一无二的亮点介绍出来，是否让面试官觉得新鲜有趣。比如有个学生介绍自己从180斤减重到130斤的故事，讲的好了这就是“毅力、耐力、目标拆解、执行力”的能力体现。
> **第三，匹配（position），**是否了解岗位职责要求，对应到自己介绍的每个要点中；是否与应聘公司文化一致，是否与面试官自然流畅交流；是否关注面试官对什么比较感兴趣；

如果以上你都打勾，那你的“自我介绍”至少80分啦！



我叫XXX，来自xxxx大学xxxx专业

今天来应聘前端开发工程师这个岗位，关于我个人，

第一，对事情的处理沉着冷静，能够分析原因，并解决问题，举例

第二，有比较好的代码编写习惯，写过的代码便于别人阅读与优化，举例

第三，在xxx项目中，主要负责数据的交互，以及页面的样式布局和优化，举例

等等。。。。



## 2020.08.10

### 公司一

> ## 面试问题
>
> 1. vue的生命周期介绍一下
>
>        beforecreated：el 和 data 并未初始化  创建前
>            
>        created:完成了 data 数据的初始化，el没有  创建后
>            
>        beforeMount：完成了 el 和 data 初始化 挂载前
>                        
>        mounted ：完成挂载  挂载后
>                        
>        beforeUpdate 更新前
>                   updated 更新后
>             
>                   beforeDestroy 销毁前
>        destroyed 销毁后
>         
>            2. 当加载资源过大时怎么处理？
> 
>    ```
>     前端可以用cdn加载资源文件
>    打包时不打包map
>     路由懒加载
>    或者后端进行分段处理
>    ```
> 
> 3. 关于vue组件的通信，他们是怎么通信的？
> 
>    ```
>     props和$emit(常用)
>    $attrs和$listeners
>     中央事件总线（非父子组件间通信）
>    v-model
>    provide和inject
>    $parent和$children
>    vuex
>    ```
> 
> 4. 手机翻转，怎么让页面也跟着翻转过来？
> 
>    ```javascript
>     /*屏幕翻转*/
>        window.addEventListener(window['onorientationchange'] ? 'orientationchange' : 'resize', function(){
>           //do someing...
>        }, false);
>    ```
> 
> 5. 什么是mvvm?
> 
>    ```
>     model view viewmodel
>    ```
>
> 





### 公司二

> ## 面试问题
>
> 1. js的作用域说一下有什么区别？
>
> ```
>局部作用域，全局作用域
> ```
>
> 2. vue的生命周期？
> 
> ```
>beforecreated：el 和 data 并未初始化  创建前
> 
>created:完成了 data 数据的初始化，el没有  创建后
> 
> beforeMount：完成了 el 和 data 初始化 挂载前
> 
> mounted ：完成挂载  挂载后
> 
> beforeUpdate 更新前
> updated 更新后
> 
> beforeDestroy 销毁前
> destroyed 销毁后
> ```
> 
> 3. 现有一个需求，一个列表中，怎么判断未完成和已完成的？
> 
> ```
>通过一个变量来判断
> ```
>
> 4. js函数和变量的优先级哪个高？
> 
> ```
>函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会被变量赋值覆盖。
> ```
>
> 5. es6你了解哪些，并说明一下作用？

## 2020.08.12

### 公司三

> ## 面试问题
>
> 1. 块级元素的水平居中方法都有哪些
>
> ```
>（1）绝对定位（已知宽高）
> （2）display:flex
>（3）绝对定位+CSS3 transform
> （4）已知子元素的宽和高，设置其样式属性position:absolute;top:0;left:0;bottom:0;right:0;margin:auto;
> ```
> 
> 2. 怎么样的操作会引起页面的重绘和重排
> 
> ```
>简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。而且，重排必然带来重绘，但是重绘未必带来重排。比如，改变某个元素的背景，这个就不涉及元素的几何属性，所以只发生重绘。
> ```
>
> 3. es6都有哪些新特性
> 
> ```
>let 
> const
>箭头函数=>  
> 
> map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。
> 
> reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数：
> 
> promise 
> 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
> 感觉跟java的Future类很像啊，有木有！
> 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。
> 
> 什么是模块化
> 模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。
> 
> 而JS中没有包的概念，换来的是 模块。
> 
> 模块功能主要由两个命令构成：export和import。
> 
> export命令用于规定模块的对外接口，
> import命令用于导入其他模块提供的功能。
> ```
> 
> 4. 数组去重都有哪些
> 
> ```
>(1)Array.from(new Set(arr))
> (2)[ ...new Set(arr) ]
>(3)sort
> https://segmentfault.com/a/1190000016418021
> ```
> 
> 5. 数组去重的过程是怎么实现的，说一下
> 
> ```
>略
> ```
>
> 6. vue里面的data为什么是函数而不是对象
> 
> ```
>js中对象是引用类型，而引用类型存储的是指向值的指针，这样做是为了节省内存，引用类型的赋值是变量指针的赋值，不是真的拷贝，他们之间的值是会相互干扰的，而在开发vue项目中我们有多组件，如果组件的data是对象，那么，当我们修改其中的一个参数，那所有使用这个参数的页面都会跟着改变，这显然不是我们需要的。
> 用function return 其实就相当于申明了新的变量，相互独立，自然就不会有这样的问题；每个实例维护一个被返回的对象的独立的拷贝。
>```
> 
> 7. js的引用类型都有哪些
> 
> ```
>引用类型：Object、Array、RegExp、Date、Function
> 区别：引用类型值可添加属性和方法，而基本类型值则不可以。
>```
> 
> 8. vue中 v-for标签里key的作用
> 
> ```
>“v-for key的作用：目前可以理解为遍历数组或元素中的唯一标识，增加或删减元素时，通过这个唯一标识key判断是否是之前的元素，并且该元素key的值是多少。这个唯一标识是保持不变的。”
> ```
>
> 9. 箭头函数和function有什么区别
> 
> ```
>（1）箭头函数全都是匿名函数
> （2）箭头函数不能用于构造函数
>（3）箭头函数中this的指向不同
> 	this一直是让初学者比较头疼的概念。在普通函数中，this总是指向调用它的对象。如果用作构造函数，它指向创建的对象实例。
> 	箭头函数的this指向的是全局，也就是所在的作用域的对象。比如obj这个对象。如果没有obj，它会指向window
> ```
> 
> 10. vue项目的加载优化方法
> 
> ```
>（1）代码包优化
> 屏蔽打包sourceMap
>对项目代码中的JS/CSS/SVG(*.ico)文件进行gzip压缩
> （2）对路由组件进行懒加载
> （3）源码优化
> 	v-if 和 v-show选择调用
> 	为item设置唯一key值
> 	细分vuejs组件
> 	减少watch的数据
> 	内容类系统的图片资源使用懒加载
> 	SSR(服务端渲染)
> （4）用户体验优化
> 	better-click防止iphone点击延迟（在开发移动端vuejs项目时，手指触摸时会出现300ms的延迟效果，可以采用better-click对ipone系列的兼容体验优化。）
> 	菊花loading
> 	骨架屏加载
> （5）用cdn加载资源文件
> ```
> 
> 11. 深拷贝和浅拷贝
> 
> ```
>个人理解
> 浅拷贝：从外部引用进来的值，在当前组件data里，定义一个变量值为引进来的值。当改变定义的这个变量值时，从外部引用进来的值也会被覆盖而跟着改变。
>深拷贝：当改变定义的这个变量值时，外部的值不会改变。
> 
> 
> 
> 浅拷贝：所谓的浅拷贝就是复制一份引用数据类型的地址，当改变了内存中数据的某一个值的话，也会影响到另一个对象（拷贝的是索引不是数据）
> 
> 深拷贝：所谓的深拷贝就是复制一份引用数据类型的数据，当改变了数据的某一个值的话，不会影响到另一个对象（注意深拷贝是拷贝的数据，而不是索引，浅拷贝拷贝的是索引而不是数据）
> ```
> 
> 12. vue的跨域问题如何解决
> 
> ```
>方法一：后台更改header
> header('Access-Control-Allow-Origin:*');//允许所有来源访问 
>header('Access-Control-Allow-Method:POST,GET');//允许访问的方式 　　
> 方法二：使用JQuery提供的jsonp 
> methods: { 
> getData () { 
>   var self = this 
>   $.ajax({ 
>     url: 'http://f.apiplus.cn/bj11x5.json', 
>     type: 'GET', 
>     dataType: 'JSONP', 
>     success: function (res) { 
>       self.data = res.data.slice(0, 3) 
>       self.opencode = res.data[0].opencode.split(',') 
>     } 
>   }) 
> } 
> }
> 方法三：使用http-proxy-middleware 代理解决（项目使用vue-cli脚手架搭建）
> 1.打开config/index.js,在proxyTable中添写如下代码：
>       proxyTable: { 
>     '/api': {  //使用"/api"来代替"http://f.apiplus.c" 
>       target: 'http://f.apiplus.cn', //源地址 
>       changeOrigin: true, //改变源 
>       pathRewrite: { 
>         '^/api': 'http://f.apiplus.cn' //路径重写 
>         } 
>     } 
>   }
> 2.使用axios请求数据时直接使用“/api”：
>       getData () { 
>    axios.get('/api/bj11x5.json', function (res) { 
>      console.log(res) 
>    })
> ```
> 
> 13.*POST和GET是HTTP协议中最常用的两种传参方式，这里小小总结一下两者的区别，欢迎补充~！*
> 
> | 请求方式         | GET                                | POST                             |
>| ---------------- | ---------------------------------- | -------------------------------- |
> | 参数位置         | url的query中                       | 一般在content中，query也可       |
>| 参数大小         | 受限于浏览器url大小，一般不超过32K | 1G                               |
> | 服务器数据接收   | 接收1次                            | 根据数据大小，可分多次接收       |
> | 适用场景（语义） | 从服务器端获取数据，不做增删改     | 向服务器提交数据，如做增删改操作 |
> | 安全性           | 参数携带在url中，安全性低          | 相对于GET请求，安全性更高        |



## 2020.08.14

### 公司四

都是web端问题，主要是细节。



## 2020.08.21

### 公司五

> ## 面试问题
>
> 1. flex的相关问题flex:1什么意思，flex:0 0 100px什么意思
>
> ```
> flex:1  
> flex属性 是 flex-grow、flex-shrink、flex-basis三个属性的缩写。
> 
> 推荐使用此简写属性，而不是单独写这三个属性。
> flex-grow：定义项目的的放大比例；
> flex-shrink：定义项目的缩小比例；
> flex-basis： 定义在分配多余空间之前，项目占据的主轴空间（main size），浏览器根据此属性计算主轴是否有多余空间，
> 
> 所以flex属性的默认值为：0 1 auto （不放大会缩小）
> flex为none：0 0 auto  （不放大也不缩小）
> flex为auto：1 1 auto  （放大且缩小）
> 
> flex：1即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。
> 
> 
> ```
>
> 2. js的原型链是什么？原型是什么？
>
> ```
> 什么是原型：
> 
> 	任何对象都有一个原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的prototype指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有prototype，只有方法才有prototype。
> 
> 什么是原型链？
> 
> 	原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有_proto_指向了。
> ```
>
> 3. v-model双向绑定原理
>

![13804866-b94b30ef566c63e9](/img/pic/13804866-b94b30ef566c63e9.jpg)

![13804866-d024abc8b6fd7624](/img/pic/13804866-d024abc8b6fd7624.jpg)

> ```
> v-model本质上是 :value和v-on的结合体，就是绑定他的value,通过v-on触发，从而更新数据
> 双向绑定得的实现主要依赖于Object.defineProperty(),通过这个函数可以监听到get,set事件
> 
> 其中observer是最主要的部分，用Object.defineProperty来实现数据的劫持，然后用他的set,get方法
> 来通知订阅者，触发update方法，从而实现更新视图
> 
> 订阅者模式：每一个{{name}} v-model=‘name’都会添加一个订阅者，从而监听不同部分的变化，每一部分变化时都会循环触发相应的订阅者，更新到页面中。
> ```
>
> 4. 垂直居中的方法说一下，不知道宽和高的情况下
>
> ```
> 1.transform: translateY(-50%);
> 2.display: flex;
> align-items: center; /*定义body的元素垂直居中*/
> justify-content: center; /*定义body的里的元素水平居中*/
> ```
>
> 5. promise都有哪些状态？
>
> ```
> promise 有三个状态：
> 1.pending 是 初始状态
> 2.fulfilled 是 操作成功的状态
> 3.rejected 是 操作失败的状态
> ```
>
> 6. 有一const a={1,2,3} ，然后设置a={1,2}，这样正确嘛？是否会报错。让a[1]=5  ，那么a ={1,5,3}，这样是否正确
>
> ```
> const的用法考查
> ```
>
> 7. jq有一个特点是，可以在jq.css()后再加.css(),那么这种链式调用原理说下
>
> ```
> 1.实现链式编程的核心，是对象中的每一个方法都会返回当前对象。
> 2.在方法中，js提供一个this的关键字，表示当前对象。
> ```
>



### 公司六

> ## 面试问题
>
> 1. 深拷贝和浅拷贝说明一下
>
> ```
>略
> ```
>
> 2. 有一json = {a,b,c},这里后面再添加一个d，如何添加？
> 
> ```
> ...{d}
> ```
> 
> 3. $set的用法，动态添加新属性
> 
>    ```
>    this.$set(Object, key, value)
> 
>    var key = 'content'; //这种主要用于当对象中某个属性值动态生成时处理方式
> 
>    this.$set('info.'+key, 'what is this?');
>    或
>    this.$set('info.content', 'what is this?');
>    ```
>
> 4. 防抖和节流
>
>    ```
>    对防抖和节流的理解及其应用场景
>          
>    在开发中，我们常常会去监听滚动事件或者用户输入框验证事件，如果事件处理没有频率限制，就会加重浏览器的负担，影响用户的体验感，
> 	         
>    因此，我们可以采取防抖（debounce）和节流（throttle）来处理，减少调用事件的频率，达到较好的用户体验。
>          
>    防抖（debounce）：
>    
>   　　在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时，重新出发定时器。
>    
>   　　例子：
>    
>    　　function debounce(fn, wait) {
>      var timeout = null;// 使用闭包，缓存变量  return function() {
>            if(timeout !== null) {
>              console.log('清除定时器啦')
>              clearTimeout(timeout);  //清除这个定时器
>            }
>            timeout = setTimeout(fn, wait);
>        }
>     }
>      // 处理函数
>     function handle() {
>          console.log(Math.random());
>      }
>      var container = document.getElementById('container')
>      container.addEventListener('scroll', debounce(handle, 1000));
>    
>    节流（throttle）：
>   
>    　　规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
>   
>    　　例子：
>    
>    　　var throttle = function(func, delay) {
>        var timer = null; // 使用闭包，缓存变量
>        var prev = Date.now(); // 最开始进入滚动的时间
>        return function() {
>         var context = this;   // this指向window
>          var args = arguments;
>         var now = Date.now();
>          var remain = delay - (now - prev); // 剩余时间
>          clearTimeout(timer);
>          // 如果剩余时间小于0，就立刻执行
>         if (remain <= 0) {
>            func.apply(context, args);
>           prev = Date.now();
>          } else {
>            timer = setTimeout(func, remain);
>          }
>        }
>     }
>      function handle() {
>         console.log(Math.random());
>      }
>     var container = document.getElementById('container')
>      container.addEventListener('scroll', throttle(handle, 1000));
>
> 
>
>    　　防抖(debounce)
> 
>    　　　　search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
>
>    　　　　window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
>
>    　　节流(throttle)
> 
>    　　　　鼠标不断点击触发，mousedown(单位时间内只触发一次)
>
>    　　　　监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断

## 2020.08.27

### 公司七

> ## 面试问题
>
> 1. 关于vue的通信都有哪些？
>
>    ```
>     props和$emit(常用)
>    $attrs和$listeners
>     中央事件总线（非父子组件间通信）
>    v-model
>    provide和inject
>    $parent和$children
>    vuex
>    ```
> 
> 
> 
> 2. 常用的ui框架
>
>       ```
>     elementUI
>    iView
>     LayUI
>    Bootstrap
>    Ant Design
>    ```
> 
> 

## 2020.09.01

### 公司八

> ## 面试问题
>
> 1. 关于vue的路由守卫
>
> ```
>正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。
> 一、全局前置守卫beforEach
>守卫方法接收三个参数：
> 1.to：即将要进入的目标路由对象
> 2.from：当前导航正要离开的路由
> 3.next：执行下一步
> 
>  /**
>         * @param {to} 将要去的路由
>         * @param {from} 出发的路由
>         * @param {next} 执行下一步
>   */
>  router.beforeEach((to, from, next) => {
>      document.title = to.meta.title || '卖座电影';
>      if (to.meta.needLogin && !$store.state.isLogin) {
>          next({
>              path: '/login'
>          })
>      } else {
>          next()
>      }
>  })
> 
> 二、全局后置钩子afterEach（少用）
> 全局后置钩子与全局前置守卫类似，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身
> 
>  router.afterEach((to, from) => {
>    // ...
> })
> 
> 三、路由独享的守卫beforeEnter
> 1.使用方法与全局守卫相同
> 2.不同的是：全局守卫可以作用于全局，路由独享守卫只作用于被设置守卫的路由
> 
>      //登录模块
>      path: '/login',
>      component: () => import('@/views/login'),
>      beforeEnter: (to, from, next) => {
>          if (to.meta.needLogin && !$store.state.isLogin) {
>              next({
>                  path: '/login'
>              })
>          } else {
>              next()
>          }
>      }
> 四、组件内的守卫
> 可以在路由组件内直接定义以下路由导航守卫：
> （1）beforeRouteEnter
> 
> 在渲染该组件的对应路由被 confirm 前调用
> 不！能！获取组件实例 this，因为当守卫执行前，组件实例还没被创建
> 可以通过 next 获取data中的数据
> 
> data() {
>  return {
>    name: "Grayly"
>  };
> },  
> beforeRouteEnter: (to, from, next) => {
>  next(vm => {
>    alert("hello" + vm.name);
>  })
> },
> 
> （2）beforeRouteUpdate
> 这个方法是vue-router2.2版本加上的。因为原来的版本中，如果一个在两个子路由之间跳转，是不触发beforeRouteLeave的。这会导致某些重置操作，没地方触发。在之前，我们都是用watch 的。但是通过这个勾子，我们有了更好的方式。
> 
> beforeRouteUpdate (to, from, next) {
>  // 在当前路由改变，但是该组件被复用时调用
>  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
>  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
>  // 可以访问组件实例 `this`
> },
> 
> （3）[图片上传失败...(image-dcb01f-1558094116913)]
> 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。
> 可以访问组件实例 this
> 
> beforeRouteLeave: (to, from, next) => {
>  if (confirm("你确定要离开吗") == true) {
>    next();
>  } else {
>    next(false);
>  }
> },
> 
> 
> 第一种：history.back();
> 
> 第二种：this.$router.go(-1);
> ```
> 
> 2. JavaScript原型，原型链？有什么特点？
> 
> ```
>1.原型对象也是普通的对象，是对象一个自带隐式的proto属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。
> 2.原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。
>```
> 

## 2020.09.03

### 公司九

> ## 面试问题
>
> 1. vue的优点
>2. vuex的优缺点
> 3. 关于垂直居中
>

### 公司十

> ## 面试问题
>
> 1. http协议是什么
>2. js的闭包是什么
> 3. js的原型链是什么
>4. 什么叫前端工程化
> 5. call和apply
> 6. react和vue的区别
> 

### 公司十一

> ## 面试问题
>
> 1. 关于react的看法
>2. var,let,const的区别